/*
    ALL MOVEMENT METHODS SHOULD RETURN A LIST OF MOVES GENERATED BY THAT METHOD
*/

export default class Moves {
    constructor(currPos, piece, stateManager) {
        this.currPos = currPos;
        this.manager = stateManager;
        this.piece = piece;
        this.cols = Number(this.manager.getBoard().getColumns());
        this.rows = Number(this.manager.getBoard().getRows());
    }
    #smallDimension() {
        if(this.cols < this.rows) {
            return this.cols;
        }
        return this.rows;
    }
    canTake(pos) {
        if (this.piece.getColor() != this.manager.getPieceColor(pos)) {
            return true;
        }
        return false;
    }

    #onSameRow(pos1, pos2) {
        if (this.manager.getRow(pos1) == this.manager.getRow(pos2)) {
            //console.log(pos1 + " and " + pos2 + " same row");
            return true;
        }
        return false;
    }
    #onSameCol(pos1, pos2) {
        if (this.manager.getColumn(pos1) == this.manager.getColumn(pos2)) {
            //console.log(pos1 + " and " + pos2 + " ARE on same col");
            return true;
        }
        //console.log(pos1 + " and " + pos2 + " NOT on same col");
        return false;
    }

    // STEP AND TAKE FORWARD N STEPS
    stepVertical(numSteps) {
        let move = [];
        let step = this.currPos + (this.cols * this.piece.getDirection() * numSteps);
        if (!this.manager.getTile(step).hasPiece()) {
            move.push(step);
        }
        return move;
    }
    // pawn only move
    doubleJump() {
        let move = [];
        let step1 = this.currPos + (this.cols * this.piece.getDirection() * 1);
        let step2 = this.currPos + (this.cols * this.piece.getDirection() * 2);
        if (!this.manager.getTile(step1).hasPiece() && !this.manager.getTile(step2).hasPiece()) {
            move.push(step2);
        }
        return move;
    }
    takeVertical(numSteps) {
        let take = [];
        let step = this.currPos + (this.cols * this.piece.getDirection() * numSteps);
        if (this.manager.getTile(step).hasPiece() && this.canTake(step)) {
            take.push(step);
        }
        return take;
    }

    enPassant() {
        let checks = [];
        let moves = [];

        this.manager.undoMove();

        checks = checks.concat(this.takeL(1,2));

        for(let i = 0; i < checks.length; i++) {
            if (this.manager.getTile(checks[i]).getPiece().getName() == 'Pawn') {
                moves.push(checks[i] - this.getBoard().getColumns());  // the piece was a pawn, can take it.
            }
        }

        this.manager.redoMove();
        return moves;
    }

    // STEP AND TAKE HORIZONTAL N STEPS
    stepHorizontal(numSteps) {
        let moves = [];
        let step1 = this.currPos + numSteps;
        let step2 = this.currPos - numSteps;

        if(!this.manager.getTile(step1).hasPiece() && this.#onSameRow(step1, this.currPos)) {
            moves.push(step1);
        }
        if(!this.manager.getTile(step2).hasPiece() && this.#onSameRow(step2, this.currPos)) {
            moves.push(step2);
        }

        return moves;
    }
    takeHorizontal(numSteps) {
        let takes = [];
        let step1 = this.currPos + numSteps;
        let step2 = this.currPos - numSteps;

        if(this.manager.getTile(step1).hasPiece() && this.#onSameRow(step1, this.currPos) && this.canTake(step1)) {
            takes.push(step1);
        }
        if(this.manager.getTile(step2).hasPiece() && this.#onSameRow(step2, this.currPos) && this.canTake(step2)) {
            takes.push(step2);
        }

        return takes;
    }

    // MOVE AND TAKE Forward x and sideways y
    moveL(stepsSideways, stepsForward) {
        let moves = [];

        let forward = this.currPos + (this.cols * this.piece.getDirection() * stepsForward);
        let move1 = forward - stepsSideways;
        let move2 = forward + stepsSideways;

        if (this.#onSameRow(move1, forward) && !this.manager.getTile(move1).hasPiece()) {
            //console.log("pushed " + move1);
            moves.push(move1);
        }
        if (this.#onSameRow(move2, forward) && !this.manager.getTile(move2).hasPiece()) {
            //console.log("pushed " + move2);
            moves.push(move2);
        }
        return moves;
    }
    takeL(stepsSideways, stepsForward) {
        let takes = [];

        let forward = this.currPos + (this.cols * this.piece.getDirection() * stepsForward);
        let take1 = forward - stepsSideways;
        let take2 = forward + stepsSideways;

        if (this.#onSameRow(take1, forward) && this.manager.getTile(take1).hasPiece() && this.canTake(take1)) {
            takes.push(take1);
        }
        if (this.#onSameRow(take2, forward) && this.manager.getTile(take2).hasPiece() && this.canTake(take2)) {
            takes.push(take2);
        }
        return takes;
    }

    // SLIDE MOVES
    slideForward() {
        let moves = [];
        let takes = [];

        let forwardStep;
        let step = this.currPos;
        let forwardCollide = false;
        while (forwardCollide == false) {
            forwardStep = step + this.cols;

            if (forwardStep >= (this.rows * this.cols)) {
                forwardCollide = true;
            }
            if (!this.manager.getTile(forwardStep).hasPiece()) {
                moves.push(forwardStep);
            }
            else if (this.canTake(forwardStep)) {
                takes.push(forwardStep);
                forwardCollide = true;
            }
            else {
                forwardCollide = true;
            }
            step = forwardStep;
        }
        return {
            moves: moves,
            takes: takes
        };
    }

    slideBackward() {
        let moves = [];
        let takes = [];

        let backStep;
        let step = this.currPos;
        let backwardCollide = false;
        while (backwardCollide == false) {
            backStep = step - this.cols;
            if (backStep < 0) {
                backwardCollide = true;
            }
            if (this.manager.getTile(backStep).hasPiece() == false) {
                moves.push(backStep);
            }
            else {
                backwardCollide = true;
                if (this.canTake(backStep)) {
                    takes.push(backStep);
                }
            }
            step = backStep;
        }
        return {
            moves: moves,
            takes: takes
        };
    }

    slideLeft() {
        let moves = [];
        let takes = [];
        let leftStep;
        let step = this.currPos;
        let leftCollide = false;
        while (leftCollide == false) {
            leftStep = step - 1;
            // check if on same row
            if (leftStep < 0 || this.manager.getRow(leftStep) != this.manager.getRow(this.currPos)) {
                leftCollide = true;
                break;
            }
            if (this.manager.getTile(leftStep).hasPiece() == false) {
                moves.push(leftStep);
            }
            else {
                leftCollide = true;
                if (this.canTake(leftStep)) {
                    takes.push(leftStep);
                }
            }
            step = leftStep;
        }
        return {
            moves: moves,
            takes: takes
        };
    }

    slideRight() {
        let moves = [];
        let takes = [];
        let rightStep;
        let step = this.currPos;
        let rightCollide = false;
        while (rightCollide == false) {
            rightStep = step + 1;
            // check if on same row
            if ((rightStep >= this.cols * this.rows) || this.manager.getRow(rightStep) != this.manager.getRow(this.currPos)) {
                rightCollide = true;
                break;
            }
            if (this.manager.getTile(rightStep).hasPiece() == false) {
                moves.push(rightStep);
            }
            else {
                rightCollide = true;
                if (this.canTake(rightStep)) {
                    takes.push(rightStep);
                }
            }
            step = rightStep;
        }
        return {
            moves: moves,
            takes: takes
        };
    }

    // Diagonal Slides (same inputs as a movL)
    slideDiagonal(sideSteps, stepsForward) {
        let moves = [];
        let takes = [];

        let collision = false;
        let counter = 0;
        let pos = this.currPos;
        while(!collision && counter < 1000) {

            let forward = pos + (this.cols * this.piece.getDirection() * stepsForward);
            let step = forward + sideSteps;

            if (this.#onSameRow(step, forward) && !this.manager.getTile(step).hasPiece()) {
                moves.push(step);
                //console.log("move " + step);
            }
            else if (this.#onSameRow(step, forward) && this.manager.getTile(step).hasPiece() && this.canTake(step)) {
                takes.push(step);
                collision = true;
                //console.log("take " + step);
            }
            else {  // this happens when you bump into an ally piece
                collision = true;
            }
            pos = step;
            counter++;
        }

        return {
            moves: moves,
            takes: takes
        }

    }
}
